<!--

Austin Lasher
CAP4720 - Computer Graphics
Three.js Board Game

-->
<!DOCTYPE html>
<html>

<head>
	<title>Three.js - UNO!</title>
	
	<style type="text/css">
		html {
			height: 100%;
			overflow: hidden;
		}
		
		body {
			margin: 0;
			padding: 0;
			height: 100%;
			overflow: auto;
			
			color: #fff;
			font-family: "Helvetica Neue", "Arial", sans-serif;
		}
		
		canvas {
			display: block;
			width: 100%;
			height: 100%;
			padding: 0;
			margin: 0;
		}
		
		#container {
			width: 100%;
			height: 100%;
			padding: 0;
			margin: 0;
			background-color: #1E1E20;
			color: #FFFFFF;
			font-size: 12px;
			position: absolute;
		}
	</style>	
	
</head>

<script type="text/javascript" src="libs/jquery-2.1.4.min.js"></script>
<script type="text/javascript" src="libs/three.min.js"></script>
<script type="text/javascript" src="cardloader.js"></script>

<body>

	<div id="buttons">
		<a href="#" onclick="submitWild('r')">red</a><br>
		<a href="#" onclick="submitWild('g')">green</a><br>
		<a href="#" onclick="submitWild('b')">blue</a><br>
		<a href="#" onclick="submitWild('y')">yellow</a>
	</div>
	
	<div id="container">
	
	</div>
	
	<script type="text/javascript">
		
		// color scheme, "Sea Wolf" from color.adobe.com
		var RED = 0xDC3522;
		var CREAM = 0xD9CB9E;
		var NAVY = 0x374140; 
		var GRAY = 0x2A2C2B;
		var DARK = 0x1E1E20;
		
		if(typeof Worker === undefined) {
			console.log("Your browser does not support web workers.");
		}
		
		var cardstate = new Worker("cardstate.js");
		cardstate.onmessage = function(event) {
			var msgContent = event.data.content;
			switch(event.data.type) {
				case "newGame":
					console.log("New game starting!");
					break;
				case "invalidMove":
					showInvalidMoveMessage();
				case "turnStart":
					turnStart(msgContent.player, msgContent.topCard, msgContent.hand);
					break;
				case "colorQuery":
					askForColor(msgContent.player, msgContent.card);
					break;
				default:
					console.log("did not recognize message from cardstate.js");
			}
		}
		
		// This would be pretty cool, but the "necessity/implementation time" ratio seems a little low to me :)
		/*var cardloader = new Worker("cardloader.js");
		var cardMaterials = [];
		cardloader.onmessage = function(event) {
			var msgContent = event.data.content;
			switch(event.data.type) {
				case "complete":
					break;
				default:
					console.log("did not recognize message from cardloader.js");
			}
		}*/
		
		var gameInitialized = false;
		
		// Start the game!
		$("#buttons").hide();
		if(texturesLoaded) clientInit();
		
		
		////////////////////////////////////////////////
		////////   GAME STATE FUNCTIONS   //////////////
		////////////////////////////////////////////////
		
		function clientInit() {
			gameInitialized = true;
			graphicsInit();
			startNewGame();
		}
		
		// Just call this, and it'll run the init function on the server
		// It will also start the first game, immediately after initialization
		function startNewGame() {
			cardstate.postMessage({
				"type": "newGame",
				"content": {
					"numPlayers": 4,
					"startingPlayer": 0
				}
			});
		}
		
		// Called automatically when a player submits a move that is invalid
		function showInvalidMoveMessage() {
			console.log("That move doesn't work! The color OR the number needs to match the card on top of the stack.");
		}
		
		// When a player's turn starts, this function is called
		function turnStart(player, topCard, hand) {
			// Rotate the camera to this side of the board :)
			printCard(topCard, "Top card is: ");
			console.log("It's player "+player+"'s turn!");
			printHand(hand);
			
			// Here we go... actual graphics stuff
			makeOurCards(hand);
		}
		
		// Tell the worker that this player is playing this card
		// The card isn't an actual card object, it's the integer index of the card to play from the array the worker gave us.
		function playCard(player, card) {
			cardstate.postMessage({
				"type": "playCard",
				"content": {
					"player": player,
					"card": card
				}
			});
		}
		
		// Tell the web worker some given player wishes to draw a card
		function drawCard(player) {
			cardstate.postMessage({
				"type": "drawCard",
				"content": {
					"player": player
				}
			});
		}
		
		var wildplayer, wildcard;
		
		function askForColor(player, card) {
			// show a dialog that asks for the color of the wild card here
			$("#buttons").show();
			
			wildcard = card;
			wildplayer = player;
		}
		
		// After the box shows, allow each button to "submit" 
		function submitWild(color) {
			wildcard.color = color;
			cardstate.postMessage({
				"type": "colorSubmit",
				"content": {
					"player": wildplayer,
					"card": wildcard
				}
			});
			$("#buttons").hide();
		}
		
		////////////////////////////////////////////////
		///////////   RENDER FUNCTIONS   ///////////////
		////////////////////////////////////////////////
		
		var scene, renderer, camera, light;
		var cube, table;
		var mouse = new THREE.Vector3();
		var raycaster = new THREE.Raycaster();
		var container = document.getElementById("container");
		var thisPlayer = 0;
		
		function graphicsInit() {
			
			// Scenes are important!
			scene = new THREE.Scene();
			
			// Make that renderer!
			renderer = new THREE.WebGLRenderer();
			renderer.setClearColor( 0x000000, 1.0 );
			renderer.setSize( window.innerWidth, window.innerHeight );
			
			// Make/add that Camera
			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
			camera.position.x = 0;
			camera.position.y = -200;
			camera.position.z = 200;
			camera.lookAt( scene.position );
			
			// Make/add that Light
			light = new THREE.SpotLight( 0xFFDBCE ); // 0xBC9884
			
			light.shadowCameraNear = 10;
			light.shadowCameraFar = 500;
			light.castShadow = true;
			light.position.set( 100, 0, 200 );
			light.lookAt(scene.position);
			light.intensity = 1.0;
			scene.add(light);
			
			ambientLight = new THREE.SpotLight( 0xFFFFFF );
			ambientLight.intensity = 0.5;
			ambientLight.position.set( 0, 250, 250 )
			scene.add(ambientLight);
			
			table = new THREE.Group();
			makeBoard();
			scene.add( table );
			
			// 
			//cardTest();
			// table.rotation.x = -Math.PI / 5;
			// table.position.y = 10;
			
			// Add the canvas element to our container
			container.appendChild( renderer.domElement );
			
			// Intentionally start an infinite loop
			render();
		}
		
		function makeBoard() {
			var woodtex = THREE.ImageUtils.loadTexture("images/wood2.jpg");
			var woodmat = new THREE.MeshPhongMaterial({map:woodtex});
			
			var cubeg = new THREE.PlaneGeometry(200, 200, 16);
			var cubem = new THREE.MeshBasicMaterial({
				wireframe: true
			});
			
			cube = new THREE.Mesh(cubeg, woodmat);
			//cube.position.z = -50;
			table.add(cube);
		}
		
		
		var draggableCards = [];
		function cardTest() {
			// Add a test card or two :)
			// new THREE.MeshLambertMaterial({map:cardTextures["r4"]})
			var card2 = new THREE.Mesh(cardGeometry, new THREE.MeshLambertMaterial({map:cardTextures["back"]}));
			
			// the stupid placeholder images don't work when requested via HTTP
			// was a longshot anyway :(
			// time for sleep
			
			card2.position.x = 0;
			card2.position.z = 0;
			card2.position.y = 0;
			table.add(card2);
			draggableCards.push(card2);
		}
		
		// This function will need a LOT of work for future implementations
		// Right now it statically places cards for just one player
		var gap = 8;
		var maxWidth = 150;
		var distFromCenter = 65;
		
		function makeOurCards(hand) {
			
			console.log("Making our cards!", hand);
			
			// cardwidth is defined in cardloader.js
			var width = gap*(hand.length-1) + cardWidth;
			if(width > maxWidth) {
				gap = maxWidth / hand.length;
				width = gap*(hand.length-1) + cardWidth;
			}
			
			var start = -width/2;
			var zval = 0;
			var x = start;
			for(var i = 0; i < hand.length; i++) {
				var someCard = new THREE.Mesh(cardGeometry, new THREE.MeshLambertMaterial({map:cardTextures["back"]}));
				someCard.position.x = x;
				someCard.position.y = -distFromCenter;
				someCard.position.z = zval;
				table.add(someCard);
				draggableCards.push(someCard);
				
				x += gap;
				zval += 0.2;
			}
			
		}
		
		// Main render loop
		function render() {
			
			//table.rotation.y += 0.005; 
			
			requestAnimationFrame(render);
			renderer.render( scene, camera );
		}
		
		
		////////////////////////////////////////////////
		////////   RAYTRACE / MOUSE DRAG   /////////////
		////////////////////////////////////////////////
		
    	window.addEventListener('mousedown', window.mdown, false);
    	window.addEventListener('mousemove', window.mmove, false);
    	window.addEventListener(  'mouseup', window.mup, false);
    	var offset = new THREE.Vector3();
    	var pickedUp;
    	
		function mdown(event) {
			event.preventDefault(); // note: this might give me problems later
			
			raycaster.setFromCamera(mouse.clone(), camera);
			
			var intersects = raycaster.intersectObjects(draggableCards, false);
			
			// If our ray hits one of the cards
			if(intersects.length > 0) {
				pickedUp = intersects[0].object;
				
				console.log("picked up", pickedUp);
				
				// Optional: grab the vector offset to make our drag fancy
				/*intersects = raycaster.intersectObject( pickedUp, false );
				if(intersects.length > 0) {
					offset.copy( intersects[0].point ).sub(pickedUp.position);
				}*/
			}
			
			intersects = raycaster.intersectObject(cube, false);
			if(intersects.length > 0) {
				console.log("clicked cube at point", intersects[0].point);
			}
		}
		
		function mup(event) {
			event.preventDefault();
			
			if(typeof pickedUp != "undefined") {
				pickedUp = undefined;
			}
			
		}
		
		function mmove(event) {
			event.preventDefault();
			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = -( event.clientY / window.innerHeight ) * 2 + 1;
			mouse.z = -1;
			
			// Set up raycaster
			raycaster.setFromCamera(mouse, camera);
			
			// If we've picked something up, use the raycaster to get new position
			if(typeof pickedUp != "undefined") {
				
				var intersection = raycaster.intersectObject(cube, false);
				if(intersection.length > 0) {
					pickedUp.position.copy(intersection[0].point);
				}
				
				return;
			}
			
			// Otherwise, see if we're hoving over something
			if(raycaster.intersectObjects(draggableCards, false).length > 0) {
				container.style.cursor = "move";
			} else {
				container.style.cursor = "default";
			}
			
		}
		
		////////////////////////////////////////////////
		//////////   UTILITY FUNCTIONS   ///////////////
		////////////////////////////////////////////////
		
		// Print each card from a given hand
		function printHand(hand) {
			for(var i = 0; i < hand.length; i++) {
				printCard(hand[i], "Card"+i);
			}
		}

		// Print a single card's details
		function printCard(c, msg) {
			if(c.type == "normal") {
				console.log(msg, c.type, c.color, c.number);
			} else if(c.type == "wild" || c.type == "wild4") {
				console.log(msg, c.type);
			} else {
				console.log(msg, c.type, c.color);
			}
		}
		
		// Add our event listeners
		window.addEventListener(   'resize', onWindowResize, false);
		// Update camera/size on resize
		function onWindowResize(){
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			
			renderer.setSize( window.innerWidth, window.innerHeight );
		}
		
	</script>
</body>

</html>